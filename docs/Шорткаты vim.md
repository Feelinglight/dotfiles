[Дефолтные комбинации клавиш](http://neovim.io/doc/user/quickref.html)

# Флаги

- ``nvim -u NONE`` - запуск без плагинов


# Режим вставки

- \<C-t\> - сдвинуть текст на одно выравнивание вправо
- \<C-d\> - сдвинуть текст на одно выравнивание влево
- \<C-O\> - перейти в нормальный режим для ввода одной команды. После ввода команды будет выполнен
  автоматический переход обратно в режим вставки
- \<C-r\>{register} - вставка из регистра
- \<C-p\> - вставка из yank регистра
- \<C-v\>{code} - вставка unicode символа


# Режим выделения

- gv - перейти в режим выделения и сразу выделить предыдущее выделение


# Text objects

- s - предложение


# Метки

- m{char} - установка метки char
- m{CHAR} - установка глобальной метки char
- delm! - удалить все локальные метки
- delm A-Z - удалить глобальные метки A-Z
- `{char} - переход к метке char
- '{char} - переход к строке с меткой char

## Автоматические метки

- `` - переход к месту перед последним переходом в текущем файле
- `. - переход к месту последнего изменения в текущем файле
- `^ - переход к месту последней вставки в текущем файле


# Регистры

- "{reg}{command} - выбор регистра перед выполнением команды
- " - неименованный регистр, в который не попадают строки из команд типа d,c
- 0 - регистр захвата, только для yank
- _ - blackhole, не попадают строки из любых команд
- = - регистр выражений
- \+ - системный буфер обмена
- \* - выделенный фрагмент
- % - имя текущего файла


# Перемещение по рабочей области

- \<C-y\> - сдвинуть экран вверх на 1 строку, без перемещения курсора
- \<C-e\> - сдвинуть экран вниз на 1 строку, без перемещения курсора
- g; - переход к следующему месту изменения
- g, - переход к предыдущему месту изменения
- gi - переход к последнему месту вставки с переходом в режим вставки


# Редактирование

- gP и gp - вставка с перемещением курсора в конец вставленного фрагмента


# Шаблоны

- \\v - включить режим регулярок, где не надо экранировать спец. символы
- \\c - отключить чувствительность к регистру
- \\C - включить чувствительность к регистру
- \\x - шестнадцатеричная цифра
- \\V - отключить регулярки и вайлдкарды
- \\{1-9} - захват группы регулярки
- \\0 - захват всего выражения регулярки
- \<{word}\> - поиск полного соответствия. Без \\v нужно экранировать треугольные скобки
- \\zs, \\ze - границы соответствия, используются для захвата части шаблона, при том что поиск
  осуществляется по всему шаблону.

  Пример: ``/\v"\zs[^"]+\ze"<CR>`` - поиск всего что в двойных скобках, но замена будет только
  текста внутри скобок

- :q/ - открыть историю шаблонов


# Поиск

- g* - поиск текущего слова без полного соответствия
- gn{cmd} - работает в режиме поиска, переносит курсор к следующему совпадению, выделяет его и
  применяет команду cmd
- \<C-r>\<C-w> - вставить слово под курсором в поле поиска
- /{template}/e - помещать курсор в конец совпадения, а не в начало
- //{spec_symbols} - использовать предыдущий шаблон


# Подстановка

## Флаги

- \<C-r\>/ - вставить последний шаблон в строку ввода
- g& - эквивалент ``:%s//~/&`` - применить последнюю команду подстановки ко всему файлу.

- g - заменять все слова в строке
- c - спрашивать о каждой замене

## Подстановки

- \\{1-9} - вставить группу {1-9}
- \\0 / & - вставить совпадение со всем шаблоном
- ~ - строка замены из предыдущей подстановки
- выделить текст и перейти и написать подстановку - подстановка в выделенном тексте

# Макросы

- q{register} - начало записи в регистр
- q - конец записи
- @{register} - воспроизведение макроса
- @@ - повтор последнего воспроизведенного макроса
- выделать диапазон строк + воспроизвести макрос - применить к диапазону, игнорируя ошибки

## Правка макроса в тексте

- :put {register} - вставить макрос в текст
- исправить макрос
- "{register}y$ - считать макрос обратно в регистр


# Режим Ex

- ranges:

  - {start},{end} - задание диапазона
  - . - текущая строка
  - ^ - первая строка
  - $ - последняя строка
  - % - все строки
  - выделить текст и нажать ``:`` - диапазон строк выделенного текста

- :r !\<command\> - выполнить \<command\> и вставить ее вывод в место где расположен курсор
- :{range}norm <command> - применить действия нормального режима к диапазону строк
- @: - повтор последней команды ex
- q: - открыть окно истории ex
- \<C-f> из режима Ex - перейти в окно истории ex

## Исполнение shell команд

- read !{cmd} - прочитать stdout команды в буфер
- write !{cmd} - передать содержимое буфера на вход команде


# global

``:[range] global[!] /{pattern}/ [cmd]`` - применить команду cmd к строкам, соответствующим шаблону
pattern из диапазона range

Дефолт ``[cmd]`` - p (print)

``vglobal`` (v) вместо ``global`` (g) - inVert - применить ко всем строкам, которые не попали под
шаблон

## yank

Если использовать как cmd просто yank - то будет захвачено только последнее совпадение.

``:g/re/y A`` - захватить все совпадения в регистр ``a``. Заглавная буква указывает, что нужно
добавлять в регистр, а не затирать его содержимое каждый раз.

Еще один вариант - ``:g/re/t$`` - вставить строки соответствующие шаблонам в конец файла

## range

После шаблона можно вставлять диапазоны. Пример:

``:g/{/ .+1,/}/-1 sort`` - найти все ``{``, захватить все что от строки ниже ``{`` до строки выше
``}`` и применить сортировку

Т. е. команда имеет вид ``:g/{start}/ .,{finish} [cmd]``

Или более общо - ``:g/{pattern}/[range][cmd]``

# netrw

- :E - открыть netrw
- \<C-^> - переключиться между буфером и netrw

# Орфография

- ]s - Выполняет переход к следующей орфографической ошибке
- [s - Выполняет переход к предыдущей орфографической ошибке
- z= - Предлагает варианты исправления ошибки
- zg - Добавляет текущее слово в орфографический словарь
- zw - Удаляет текущее слово из орфографического словаря
- zug - Отменяет команду zg или zu, выполненную для текущего слова


# LazyVim

```lua
-- Move Lines
map("n", "<A-j>", "<cmd>execute 'move .+' . v:count1<cr>==", { desc = "Move Down" })

-- buffers
map("n", "<leader>`", "<cmd>e #<cr>", { desc = "Switch to Other Buffer" })
map("n", "<leader>bD", "<cmd>:bd<cr>", { desc = "Delete Buffer and Window" })

-- Add undo break-points ???
map("i", ",", ",<c-g>u")
map("i", ".", ".<c-g>u")
map("i", ";", ";<c-g>u")

-- new file
map("n", "<leader>fn", "<cmd>enew<cr>", { desc = "New File" })

-- LazyVim Changelog
map("n", "<leader>L", function() LazyVim.news.changelog() end, { desc = "LazyVim Changelog" })

-- windows
map("n", "<leader>-", "<C-W>s", { desc = "Split Window Below", remap = true })
map("n", "<leader>|", "<C-W>v", { desc = "Split Window Right", remap = true })
map("n", "<leader>wd", "<C-W>c", { desc = "Delete Window", remap = true })

{ "gI", function() require("telescope.builtin").lsp_implementations({ reuse_win = true }) end, desc = "Goto Implementation" },
{ "gy", function() require("telescope.builtin").lsp_type_definitions({ reuse_win = true }) end, desc = "Goto T[y]pe Definition" },

-- search
{ '<leader>s"', "<cmd>Telescope registers<cr>", desc = "Registers" },
{ "<leader>sb", "<cmd>Telescope current_buffer_fuzzy_find<cr>", desc = "Buffer" },
{ "<leader>sR", "<cmd>Telescope resume<cr>", desc = "Resume" },
{ "<leader>ss", "<cmd>Telescope lsp_document_symbols<cr>", desc = "Resume" },

